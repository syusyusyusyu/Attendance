# 解説.md ～ 仕様書を完全理解するためのガイド ～

**情報系専門学生のための技術解説ドキュメント**

> 仕様書.mdのすべてのセクションを、プログラミング初学者〜中級者向けに徹底解説しています。

このドキュメントでは、仕様書に登場する専門用語・設計パターン・図の読み方・実装の意図を詳しく説明します。  
就職活動やポートフォリオ作成の際に「なぜこう設計したか」を論理的に説明できるようになることを目指します。

<br>

---

## 目次

| セクション | 内容 |
|:---|:---|
| **PART 1: 基礎知識** | 用語集 / MVCパターン / Service Object / Web開発の基本 |
| **PART 2: 概要の読み方** | 1分説明のコツ / 展示ポイントの意味 / デモ設計 |
| **PART 3: プロダクトの理解** | ユーザーロール / 出席ポリシー / OIC運用設定の意図 |
| **PART 4: 技術スタックの理解** | Rails 8 / Hotwire / PostgreSQL / セキュリティ設計 |
| **PART 5: 設計図の読み方** | Mermaid記法 / ER図 / クラス図 / フローチャート |
| **PART 6: データベース設計** | 正規化 / 外部キー / JSONB / インデックス |
| **PART 7: セキュリティ設計** | 認証 / 認可 / 署名トークン / 不正検知 |
| **PART 8: テスト設計** | 単体テスト / 結合テスト / 境界値テスト |
| **PART 9: 開発・運用** | 環境変数 / デプロイ / 本番運用 |
| **PART 10: 就活・ポートフォリオ** | 面接対策 / 書くべきポイント |

<br>

---
---

# PART 1: 基礎知識

---

## 1-1. 用語集（カテゴリ別）

### Web開発基礎

| 用語 | 読み方 | 意味 | このシステムでの使われ方 |
|:---|:---|:---|:---|
| HTTP | エイチティーティーピー | ブラウザとサーバーの通信規約 | すべてのリクエスト/レスポンス |
| GET | ゲット | データを取得するリクエスト | ページ表示、一覧取得 |
| POST | ポスト | データを送信するリクエスト | ログイン、出席登録 |
| PATCH | パッチ | データを部分更新するリクエスト | 出席ステータス修正 |
| DELETE | デリート | データを削除するリクエスト | ログアウト |
| Session | セッション | ログイン状態を保持する仕組み | ユーザー認証の維持 |
| Cookie | クッキー | ブラウザに保存される小さなデータ | セッションIDの保存 |

### Ruby on Rails

| 用語 | 読み方 | 意味 | このシステムでの使われ方 |
|:---|:---|:---|:---|
| MVC | エムブイシー | Model/View/Controllerの設計パターン | アプリ全体の構造 |
| ActiveRecord | アクティブレコード | RailsのORM（DB操作の仕組み） | 全Modelクラス |
| Migration | マイグレーション | DBスキーマの変更を管理する仕組み | テーブル作成・変更 |
| Gem | ジェム | Rubyのライブラリ（パッケージ） | bcrypt, rqrcode等 |
| ERB | イーアールビー | HTMLにRubyを埋め込むテンプレート | 全View |
| Turbo | ターボ | 画面遷移なしで部分更新する技術 | リアルタイム更新 |
| Stimulus | スティミュラス | 軽量なJSフレームワーク | QRスキャン、位置情報取得 |

### データベース

| 用語 | 読み方 | 意味 | このシステムでの使われ方 |
|:---|:---|:---|:---|
| PostgreSQL | ポストグレスキューエル | 高機能なリレーショナルDB | メインDB |
| PK | ピーケー | Primary Key（主キー） | 各テーブルのid |
| FK | エフケー | Foreign Key（外部キー） | テーブル間の関連 |
| UK | ユーケー | Unique Key（一意キー） | email, student_id |
| Index | インデックス | 検索を高速化する索引 | 頻繁に検索するカラム |
| JSONB | ジェイソンビー | PostgreSQLのJSON型 | settings, location |
| Transaction | トランザクション | 複数操作を1つの単位にする | 出席登録とログ記録 |

### セキュリティ

| 用語 | 読み方 | 意味 | このシステムでの使われ方 |
|:---|:---|:---|:---|
| 認証 | にんしょう | 「誰か」を確認すること | ログイン |
| 認可 | にんか | 「何ができるか」を確認すること | ロール別アクセス制御 |
| Hash | ハッシュ | 元に戻せない変換 | パスワード保存 |
| bcrypt | ビークリプト | パスワードハッシュアルゴリズム | has_secure_password |
| Token | トークン | 一時的な認証文字列 | QRコードの値 |
| 署名 | しょめい | データの改ざんを検知する仕組み | MessageVerifier |
| Rate Limit | レートリミット | 短時間の連続アクセス制限 | QRスキャン制限 |

### 設計・開発

| 用語 | 読み方 | 意味 | このシステムでの使われ方 |
|:---|:---|:---|:---|
| Service Object | サービスオブジェクト | ビジネスロジックを分離したクラス | QrScanProcessor等 |
| Validation | バリデーション | 入力値の検証 | Model層で実行 |
| Callback | コールバック | 特定タイミングで自動実行される処理 | before_save等 |
| N+1問題 | エヌプラスワンもんだい | 不要なDBクエリが大量発生する問題 | includes で解決 |
| Eager Loading | イーガーローディング | 関連データを事前に読み込む | includes, preload |

<br>

---

## 1-2. MVCパターン詳解

### MVCとは何か？

Webアプリケーションの基本的な設計パターンです。  
**責務（やるべきこと）を分離**することで、コードが整理され、修正・テストがしやすくなります。

```
┌─────────────────────────────────────────────────────────────┐
│                      ブラウザ                                │
│               (ユーザーが操作する画面)                        │
└───────────────────────┬─────────────────────────────────────┘
                        │ ① リクエスト
                        │ (例: GET /scan)
                        ▼
┌─────────────────────────────────────────────────────────────┐
│                    routes.rb                                 │
│              「どのControllerに振り分けるか」                  │
│         get '/scan' => 'qr_scans#new'                       │
└───────────────────────┬─────────────────────────────────────┘
                        │ ② 振り分け
                        ▼
┌─────────────────────────────────────────────────────────────┐
│              Controller（交通整理係）                         │
│    「リクエストを受け取り、ModelとViewを連携させる」           │
│                                                              │
│    class QrScansController < ApplicationController           │
│      def new                                                 │
│        @classes = current_user.enrolled_classes  # ③        │
│      end                                                     │
│                                                              │
│      def create                                              │
│        result = QrScanProcessor.new(...).call  # ③       │
│        if result.success?                                   │
│          redirect_to scan_path, notice: '出席完了'          │
│        else                                                 │
│          render :new, alert: result.error                   │
│        end                                                   │
│      end                                                     │
│    end                                                       │
└───────┬─────────────────────────────────────┬───────────────┘
        │ ③ データ操作を依頼                  │ ④ 表示を依頼
        ▼                                    ▼
┌───────────────────────┐      ┌───────────────────────────────┐
│   Model（倉庫係）      │      │      View（表示係）            │
│  DBとやり取りする      │      │   HTMLを組み立てる             │
│                       │      │                               │
│ class AttendanceRecord│      │ <!-- new.html.erb -->         │
│   belongs_to :user    │      │ <h1>QRスキャン</h1>           │
│   belongs_to :class   │      │ <form action="/scan">         │
│   validates :status   │      │   <input name="token">        │
│ end                   │      │   <button>送信</button>       │
│                       │      │ </form>                       │
└───────────────────────┘      └───────────────────────────────┘
        │                                    │
        │ ⑤ データ返却                       │ ⑥ HTML返却
        └─────────────┬──────────────────────┘
                      ▼
┌─────────────────────────────────────────────────────────────┐
│                      ブラウザ                                │
│              ⑦ 画面を表示                                    │
└─────────────────────────────────────────────────────────────┘
```

### なぜMVCを使うのか？

| メリット | 説明 |
|:---|:---|
| **分業しやすい** | デザイナーはViewだけ、バックエンドはModel/Controllerだけ触れる |
| **テストしやすい** | Modelのロジックを単体でテストできる |
| **再利用しやすい** | Modelは複数のControllerから使える |
| **修正しやすい** | 画面変更はViewだけ、ロジック変更はModelだけ |

### このシステムでのMVCファイル例

| 機能 | Controller | Model | View |
|:---|:---|:---|:---|
| ログイン | `sessions_controller.rb` | `user.rb` | `sessions/new.html.erb` |
| QRスキャン | `qr_scans_controller.rb` | `attendance_record.rb` | `qr_scans/new.html.erb` |
| 出席一覧 | `class_attendances_controller.rb` | `attendance_record.rb` | `class_attendances/show.html.erb` |
| レポート | `reports_controller.rb` | `attendance_record.rb` | `reports/show.html.erb` |

<br>

---

## 1-3. Service Objectパターン詳解

### なぜService Objectが必要なのか？

MVCだけだと、**Controllerが肥大化**してしまいます。

```ruby
# ❌ 悪い例：Controller に全部書いてしまう（Fat Controller）
class QrScansController < ApplicationController
  def create
    # トークン検証（20行）
    token_data = MessageVerifier.verify(params[:token])
    return render_error('無効なトークン') unless token_data
    
    # セッション検証（15行）
    session = QrSession.find(token_data[:session_id])
    return render_error('期限切れ') if session.expired?
    
    # 履修確認（10行）
    enrollment = Enrollment.find_by(user: current_user, school_class: session.school_class)
    return render_error('未履修') unless enrollment
    
    # 位置情報検証（20行）
    distance = calculate_distance(params[:lat], params[:lng], SCHOOL_LAT, SCHOOL_LNG)
    return render_error('校外') if distance > 50
    
    # 出席記録（15行）
    record = AttendanceRecord.find_or_initialize_by(...)
    record.update!(status: :present, checked_in_at: Time.current)
    
    # ログ記録（10行）
    QrScanEvent.create!(...)
    
    redirect_to scan_path, notice: '出席完了'
  end
end
# → 90行以上のメソッドになってしまう！
```

### Service Objectで分離する

```ruby
# ✅ 良い例：Service Object に切り出す
class QrScansController < ApplicationController
  def create
    result = QrScanProcessor.new(
      token: params[:token],
      user: current_user,
      location: { lat: params[:lat], lng: params[:lng] }
    ).call
    
    if result.success?
      redirect_to scan_path, notice: '出席を記録しました'
    else
      redirect_to scan_path, alert: result.error_message
    end
  end
end

# app/services/qr_scan_processor.rb
class QrScanProcessor
  def initialize(token:, user:, location:)
    @token = token
    @user = user
    @location = location
  end
  
  def call
    return failure('無効なトークン') unless verify_token
    return failure('期限切れ') unless verify_session
    return failure('未履修') unless verify_enrollment
    return failure('校外からのアクセス') unless verify_location

    create_attendance_record
    create_scan_event

    success
  end
  
  private
  
  def verify_token
    # トークン検証ロジック
  end
  
  def verify_session
    # セッション検証ロジック
  end
  
  # ... 他のprivateメソッド
end
```

### Service Objectのメリット

| メリット | 説明 |
|:---|:---|
| **Controllerがスッキリ** | 5〜10行程度に収まる |
| **テストしやすい** | Service単体でテストできる |
| **再利用しやすい** | 別のControllerからも呼べる |
| **ロジックが見つけやすい** | 「スキャン処理」→ `QrScanProcessor` |

### このシステムのService一覧

| Service | 責務 | 主なメソッド |
|:---|:---|:---|
| `AttendanceToken` | QRトークンの生成・検証 | `.generate`, `.verify` |
| `QrScanProcessor` | スキャン処理の全体統括 | `#call` |
| `QrFraudDetector` | 不正検知（失敗多発/IP集中/トークン共有） | `.check` |
| `QrScanRateLimiter` | スキャンレート制限 | `.check` |
| `QrScanEventLogger` | スキャンイベント記録 | `.log` |
| `NotificationDispatcher` | 通知配信の統括（メール/LINE/Push） | `#deliver` |
| `LineNotifier` | LINE Messaging API連携 | `#push` |
| `PushNotifier` | Web Push通知配信 | `#deliver` |
| `AttendanceFinalizer` | 締切後の自動欠席確定 | `#finalize` |
| `TermReportBuilder` | 期末レポート生成 | `#build` |

<br>

---

## 1-4. Railsの重要な機能

### has_secure_password

パスワードを安全に保存するRailsの機能です。

```ruby
# app/models/user.rb
class User < ApplicationRecord
  has_secure_password  # この1行で以下が使えるようになる
end

# 使い方
user = User.new(email: 'test@example.com', password: 'secret123')
user.save  # password_digest カラムにハッシュ値が保存される

# 認証
user.authenticate('secret123')  # => user（成功）
user.authenticate('wrong')       # => false（失敗）
```

### なぜパスワードをそのまま保存しないのか？

```
❌ 危険：パスワードをそのまま保存
  users テーブル
  | email              | password    |
  | test@example.com   | secret123   |  ← DBが漏洩したら全員のパスワードがバレる！

✅ 安全：ハッシュ化して保存
  users テーブル
  | email              | password_digest                              |
  | test@example.com   | $2a$12$K2L... (元に戻せないハッシュ値)        |
```

### bcryptの特徴

| 特徴 | 説明 |
|:---|:---|
| **一方向性** | ハッシュ値から元のパスワードは復元できない |
| **Salt付き** | 同じパスワードでも毎回異なるハッシュ値になる |
| **計算コスト調整** | わざと遅くして総当たり攻撃を防ぐ |

<br>

---

## 1-5. Hotwire（Turbo + Stimulus）詳解

### 従来のWebアプリの問題

```
[ボタンクリック]
      ↓
[サーバーにリクエスト送信]
      ↓
[サーバーが 画面全体 のHTMLを生成]
      ↓
[ブラウザが 画面全体 を再描画]  ← チラつく、遅い
```

### Hotwireの解決策

```
[ボタンクリック]
      ↓
[サーバーにリクエスト送信]
      ↓
[サーバーが 変更部分だけ のHTMLを生成]
      ↓
[ブラウザが その部分だけ 差し替え]  ← スムーズ、速い
```

### Turbo Frame

画面の一部を「フレーム」で囲み、その中だけを更新します。

```erb
<!-- 出席一覧画面 -->
<h1>出席一覧</h1>

<!-- このフレームの中だけが更新される -->
<turbo-frame id="attendance_list">
  <table>
    <% @records.each do |record| %>
      <tr>
        <td><%= record.user.name %></td>
        <td><%= record.status %></td>
      </tr>
    <% end %>
  </table>
</turbo-frame>

<!-- フィルタを変えても、この部分は再読み込みされない -->
<aside>サイドバー（広告など）</aside>
```

### Turbo Stream

サーバーから「この部分を更新しろ」という指示を送ります。

```ruby
# Controller
def create
  @record = AttendanceRecord.create!(...)
  
  respond_to do |format|
    format.turbo_stream  # → create.turbo_stream.erb を返す
  end
end
```

```erb
<!-- create.turbo_stream.erb -->
<turbo-stream action="append" target="attendance_list">
  <template>
    <tr>
      <td><%= @record.user.name %></td>
      <td><%= @record.status %></td>
    </tr>
  </template>
</turbo-stream>
```

### Stimulus

最小限のJavaScriptでインタラクションを実装します。

```html
<!-- HTML側 -->
<div data-controller="qr-scanner">
  <video data-qr-scanner-target="video"></video>
  <button data-action="click->qr-scanner#start">スキャン開始</button>
</div>
```

```javascript
// app/javascript/controllers/qr_scanner_controller.js
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static targets = ["video"]
  
  start() {
    // カメラを起動してQRスキャン
    navigator.mediaDevices.getUserMedia({ video: true })
      .then(stream => {
        this.videoTarget.srcObject = stream
      })
  }
}
```

<br>

---
---

# PART 2: 概要の読み方

---

## 2-1. 「1分でわかる」の意味と構成

### なぜ1分なのか？

- 就職面接の自己PR：約1分
- 展示会での説明：来場者は30秒〜1分で興味を判断
- エレベーターピッチ：30秒〜1分

**最初の1分で相手の興味を引けるかが勝負**です。

### 4つの観点の意図

| 観点 | 質問 | このシステムの回答 |
|:---|:---|:---|
| **体験** | 何ができるの？ | QRスキャンで出席・退室を瞬時に記録 |
| **特徴** | 他と何が違うの？ | 位置情報認証で代返を防止 |
| **強み** | なぜ優れてるの？ | 承認ワークフロー×監査ログで実運用対応 |
| **価値** | 誰が嬉しいの？ | 教員の負担軽減×学生の利便性向上 |

### 実際に言ってみる

> 「QRコードをスキャンするだけで出席登録ができるシステムです。  
> 位置情報認証で代返を防止し、承認ワークフローと監査ログで  
> 実運用にも耐える設計になっています。  
> 教員は出席管理の手間が減り、学生はスマホ1つで出席できます。」

これで約30秒。残り30秒でデモを見せると効果的です。

<br>

---

## 2-2. 展示ポイントの設計意図

### なぜ3つに絞るのか？

心理学で「マジカルナンバー」と呼ばれる法則があります。  
人が短期記憶できる数は **7±2（5〜9）個** 程度。  
展示では3つに絞ることで、確実に記憶に残ります。

### 選定基準

| 基準 | 説明 | このシステムでの例 |
|:---|:---|:---|
| **差別化** | 他にない特徴 | 位置情報認証（競合製品にはない） |
| **デモ映え** | 見た目でわかる | リアルタイム更新（動きがある） |
| **技術力** | 設計力をアピール | 3ロール運用（実務経験を示唆） |

<br>

---

## 2-3. デモの流れの設計

### 良いデモの条件

| 条件 | 理由 | このシステムでの実装 |
|:---|:---|:---|
| **短い** | 長いと飽きる | 4ステップで完結 |
| **動きがある** | 視覚的に訴求 | QRスキャン→即時反映 |
| **失敗しにくい** | トラブルで印象ダウン | シードデータで事前準備 |
| **触れる** | 体験型は記憶に残る | 来場者にスキャンしてもらう |

### デモシナリオ詳細

```
【準備】
- 教員アカウントと学生アカウントを別ブラウザで開いておく
- QRコード表示画面を出しておく

【実演】
1. 「教員がQRコードを発行します」 (5秒)
   → QR生成画面を見せる
   
2. 「学生がスマホでスキャンします」 (10秒)
   → 来場者のスマホでスキャンしてもらう
   → 位置情報の許可を求められる様子を見せる
   
3. 「出席が即座に反映されます」 (5秒)
   → 教員画面を見せ、リアルタイム更新をアピール
   
4. 「出席率や要注意者もすぐわかります」 (5秒)
   → レポート画面を見せる

【合計】約25秒
```

<br>

---
---

# PART 3: プロダクトの理解

---

## 3-1. ユーザーロールの設計意図

### ロールベースアクセス制御（RBAC）

「誰が何をできるか」を**ロール（役割）単位**で管理する方式です。

```
┌─────────────────────────────────────────────────────────────┐
│                    管理者（Admin）                           │
│  - 全ユーザーの管理                                          │
│  - 権限設定                                                  │
│  - 最終承認                                                  │
│          ┌─────────────────────────────────────┐            │
│          │         教員（Teacher）              │            │
│          │  - 担当クラスのQR発行               │            │
│          │  - 出席確認・修正                   │            │
│          │  - 申請承認                         │            │
│          │  - レポート閲覧                     │            │
│          │       ┌─────────────────────┐      │            │
│          │       │    学生（Student）   │      │            │
│          │       │  - QRスキャン       │      │            │
│          │       │  - 自分の履歴閲覧   │      │            │
│          │       │  - 出席申請         │      │            │
│          │       └─────────────────────┘      │            │
│          └─────────────────────────────────────┘            │
└─────────────────────────────────────────────────────────────┘
```

### 権限設計の3原則

| 原則 | 説明 | このシステムでの実装 |
|:---|:---|:---|
| **最小権限** | 必要最低限の権限だけ与える | 学生は自分の出席のみ閲覧可 |
| **職務分離** | 重要操作は複数人のチェック | 出席確定は管理者承認が必要 |
| **監査証跡** | 誰が何をしたか記録 | AttendanceChangeで全変更を記録 |

### Railsでの実装

```ruby
# app/models/user.rb
class User < ApplicationRecord
  enum role: { student: 0, teacher: 1, admin: 2 }
  
  def can_manage_class?(school_class)
    admin? || (teacher? && school_class.teacher_id == id)
  end
end

# app/controllers/application_controller.rb
class ApplicationController < ActionController::Base
  def require_role!(*roles)
    unless roles.any? { |role| current_user.send("#{role}?") }
      redirect_to root_path, alert: '権限がありません'
    end
  end
end

# app/controllers/class_attendances_controller.rb
class ClassAttendancesController < ApplicationController
  before_action -> { require_role!(:teacher, :admin) }
end
```

<br>

---

## 3-2. 出席ポリシーの設計意図

### なぜ設定で持つのか？

```ruby
# ❌ 悪い例：ハードコーディング
class AttendancePolicy
  LATE_AFTER_MINUTES = 20  # 変更するにはコードを修正→デプロイが必要
end

# ✅ 良い例：DBの設定テーブルで管理
class AttendancePolicy < ApplicationRecord
  # late_after_minutes カラム
  # close_after_minutes カラム
  # など
end
```

### 設定項目の意図

| 項目 | デフォルト | 意図 |
|:---|:---|:---|
| **遅刻判定** | 20分 | 電車遅延などを考慮した現実的な値 |
| **出席締切** | 20分 | 遅刻判定と同じにして「遅刻」を許容しない運用 |
| **最低出席率** | 80% | 90分授業で72分以上いれば出席とする |
| **警告欠席数** | 3回 | 3回欠席で単位取得が危うくなる想定 |
| **警告出席率** | 70% | 単位認定の最低ラインを想定 |

### ステータス判定のロジック

```ruby
# app/models/attendance_policy.rb
class AttendancePolicy
  def determine_status(scanned_at:, class_start:, class_end:)
    minutes_late = (scanned_at - class_start) / 60
    
    if minutes_late > close_after_minutes
      :outside_window  # 締切後（出席登録不可）
    elsif minutes_late > late_after_minutes
      :late  # 遅刻
    else
      :present  # 出席
    end
  end
  
  def determine_early_leave(duration_minutes:, class_duration_minutes:)
    required_minutes = (class_duration_minutes * minimum_attendance_rate / 100.0).ceil
    duration_minutes < required_minutes ? :early_leave : nil
  end
end
```

<br>

---

## 3-3. OIC運用設定の意図

### 時限設定

OIC（大阪情報コンピュータ専門学校）の実際の時間割に合わせています。

```ruby
# config/school_settings.yml
periods:
  1: { start: "09:10", end: "10:40" }
  2: { start: "10:50", end: "12:20" }
  3: { start: "13:10", end: "14:40" }
  4: { start: "14:50", end: "16:20" }
  5: { start: "16:30", end: "18:00" }
```

### 位置情報設定

| 項目 | 値 | 理由 |
|:---|:---|:---|
| 校内半径 | 50m | 校舎の大きさ + GPS誤差を考慮 |
| 精度上限 | 150m | これ以上の誤差は信頼できない |

```
        150m（精度上限）
    ┌───────────────────┐
    │                   │
    │     50m（校内）    │
    │   ┌─────────┐     │
    │   │   ⭐    │     │  ⭐ = 学校の中心
    │   │  校舎   │     │
    │   └─────────┘     │
    │                   │
    └───────────────────┘

精度 50m以内  → 「校内」と判定
精度 50m〜150m → 警告を出すが許可
精度 150m超  → 「位置情報が不正確」で拒否
```

<br>

---
---

# PART 4: 技術スタックの理解

---

## 4-1. Ruby on Rails 8

### Rails 8の新機能（このシステムで使用）

| 機能 | 説明 | 使用箇所 |
|:---|:---|:---|
| **Solid Cable** | Action CableをDBで実装 | リアルタイム更新 |
| **Solid Cache** | キャッシュをDBで実装 | セッション管理 |
| **Kamal** | デプロイツール | Render.comでは未使用 |

### なぜRailsを選んだか？

| 理由 | 説明 |
|:---|:---|
| **開発速度** | scaffold、migration、routesで高速開発 |
| **規約** | 「設定より規約」で迷わない |
| **エコシステム** | Gem（ライブラリ）が豊富 |
| **日本語情報** | Railsガイド日本語版がある |
| **就職** | Web系企業で需要が高い |

<br>

---

## 4-2. PostgreSQL

### なぜMySQLではなくPostgreSQLか？

| 機能 | PostgreSQL | MySQL |
|:---|:---|:---|
| **JSONB** | ✅ 高速検索可能 | 🔺 JSON型はあるが遅い |
| **部分インデックス** | ✅ 条件付きインデックス | ❌ なし |
| **配列型** | ✅ あり | ❌ なし |
| **Railsとの相性** | ✅ 完全対応 | ✅ 完全対応 |

### JSONBの活用例

```ruby
# settings カラムに通知設定を保存
class User < ApplicationRecord
  # settings: { email_notify: true, line_notify: false, ... }
  
  def email_notify_enabled?
    settings&.dig('email_notify') == true
  end
end

# location カラムにスキャン時の位置情報を保存
class AttendanceRecord < ApplicationRecord
  # location: { latitude: 34.123, longitude: 135.456, accuracy: 10 }
  
  def location_accuracy
    location&.dig('accuracy')
  end
end
```

### インデックスの活用

```ruby
# db/migrate/xxx_add_indexes.rb
class AddIndexes < ActiveRecord::Migration[8.0]
  def change
    # 複合インデックス（よく一緒に検索するカラム）
    add_index :attendance_records, [:school_class_id, :date]
    
    # 部分インデックス（特定条件のみ）
    add_index :attendance_records, :status, where: "status = 'absent'"
  end
end
```

<br>

---

## 4-3. Tailwind CSS

### ユーティリティファーストとは？

```html
<!-- 従来のCSS：クラス名を考えて、CSSファイルに書く -->
<div class="card">
  <h2 class="card-title">タイトル</h2>
</div>

<style>
.card {
  padding: 1rem;
  background: white;
  border-radius: 0.5rem;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
.card-title {
  font-size: 1.25rem;
  font-weight: bold;
}
</style>

<!-- Tailwind：HTMLにユーティリティクラスを直接書く -->
<div class="p-4 bg-white rounded-lg shadow">
  <h2 class="text-xl font-bold">タイトル</h2>
</div>
```

### よく使うTailwindクラス

| クラス | 意味 | CSS相当 |
|:---|:---|:---|
| `p-4` | padding: 1rem | `padding: 1rem` |
| `m-2` | margin: 0.5rem | `margin: 0.5rem` |
| `text-xl` | font-size: 1.25rem | `font-size: 1.25rem` |
| `font-bold` | font-weight: 700 | `font-weight: 700` |
| `bg-blue-500` | 青色背景 | `background-color: #3b82f6` |
| `rounded-lg` | 角丸 | `border-radius: 0.5rem` |
| `shadow` | 影 | `box-shadow: ...` |
| `flex` | flexbox | `display: flex` |
| `grid` | grid | `display: grid` |

### レスポンシブ対応

```html
<!-- sm: 640px以上、md: 768px以上、lg: 1024px以上 -->
<div class="
  p-2        // 常に適用
  sm:p-4     // 640px以上で適用
  md:p-6     // 768px以上で適用
  lg:p-8     // 1024px以上で適用
">
```

<br>

---
---

# PART 5: 設計図の読み方

---

## 5-1. Mermaid記法詳解

### Mermaidとは？

マークダウンで図を描けるツールです。GitHub、Notion、Qiitaなどで表示できます。

### 図の種類と使い分け

| 種類 | 記法 | 用途 | このシステムでの例 |
|:---|:---|:---|:---|
| フローチャート | `flowchart` | 処理の流れ | 出席登録フロー |
| シーケンス図 | `sequenceDiagram` | 時系列のやり取り | ログインシーケンス |
| クラス図 | `classDiagram` | クラスの関係 | Model/Service設計 |
| ER図 | `erDiagram` | テーブルの関係 | DB設計 |
| 状態遷移図 | `stateDiagram` | 状態の変化 | 画面遷移 |
| マインドマップ | `mindmap` | 階層構造 | 要件定義 |

### フローチャートの書き方

```markdown
# 書き方
flowchart TB  # TB=上から下、LR=左から右
  A[四角] --> B{ひし形}
  B -->|Yes| C((丸))
  B -->|No| D[(データベース)]
  
# 記号の意味
[四角]     処理
{ひし形}   分岐
((丸))     開始/終了
[(円柱)]   データベース
-->        矢印
-->|ラベル| ラベル付き矢印
```

```mermaid
flowchart TB
  A[四角] --> B{ひし形}
  B -->|Yes| C((丸))
  B -->|No| D[(データベース)]
```

### サブグラフの使い方

```mermaid
flowchart LR
  subgraph Frontend[フロントエンド]
    A[ブラウザ] --> B[JavaScript]
  end
  subgraph Backend[バックエンド]
    C[Controller] --> D[Model]
  end
  B --> C
```

<br>

---

## 5-2. ER図の読み方詳解

### 記号の意味

```
||    1（必ず1つ）
|{    1以上（最低1つ）
o{    0以上（0個でもOK）
||--o{  1対多（1人のユーザーは0個以上の出席記録を持つ）
```

### 関連の読み方

```mermaid
erDiagram
  USERS ||--o{ ATTENDANCE_RECORDS : "記録する"
  USERS ||--o{ ENROLLMENTS : "履修する"
  SCHOOL_CLASSES ||--o{ ENROLLMENTS : "持つ"
```

| 関連 | 読み方 |
|:---|:---|
| `USERS \|\|--o{ ATTENDANCE_RECORDS` | 1人のユーザーは0個以上の出席記録を持つ |
| `USERS \|\|--o{ ENROLLMENTS` | 1人のユーザーは0個以上の履修を持つ |
| `SCHOOL_CLASSES \|\|--o{ ENROLLMENTS` | 1つのクラスは0個以上の履修を持つ |

### 多対多の関係

```
USERS ←→ SCHOOL_CLASSES は多対多
  1人の学生は複数のクラスを履修
  1つのクラスには複数の学生が履修

→ 中間テーブル ENROLLMENTS で実現

USERS ||--o{ ENROLLMENTS o{--|| SCHOOL_CLASSES
```

<br>

---

## 5-3. クラス図の読み方詳解

### 記号の意味

```
+ public    外から見える
- private   外から見えない
# protected 継承先から見える

<|--  継承（子 <|-- 親）
*--   コンポジション（強い所有）
o--   集約（弱い所有）
..>   依存（使っている）
```

### このシステムのクラス図を読む

```mermaid
classDiagram
  class ApplicationController {
    +current_user
    +require_login
    #require_role!
  }
  class QrScansController {
    +new
    +create
  }
  class QrScanProcessor {
    +call()
    -verify_token()
    -verify_location()
  }
  
  ApplicationController <|-- QrScansController
  QrScansController ..> QrScanProcessor : uses
```

| 関係 | 意味 |
|:---|:---|
| `ApplicationController <\|-- QrScansController` | QrScansControllerはApplicationControllerを継承 |
| `QrScansController ..> QrScanProcessor` | QrScansControllerはQrScanProcessorを使用 |

<br>

---

## 5-4. 画面遷移図の読み方

### 状態遷移図の記号

```
[*]     開始点
-->     遷移
: ラベル  遷移条件
state   状態の定義
```

### このシステムの画面遷移を読む

```mermaid
stateDiagram-v2
  [*] --> ログイン
  ログイン --> ダッシュボード: 成功
  ログイン --> ログイン: 失敗
  ダッシュボード --> QRスキャン: 学生のみ
  ダッシュボード --> QR生成: 教員のみ
```

| 遷移 | 意味 |
|:---|:---|
| `[*] --> ログイン` | 最初にログイン画面を表示 |
| `ログイン --> ダッシュボード: 成功` | ログイン成功でダッシュボードへ |
| `ログイン --> ログイン: 失敗` | ログイン失敗で同じ画面に戻る |

<br>

---
---

# PART 6: データベース設計

---

## 6-1. 正規化とは？

### データの重複を排除する設計手法

```
❌ 悪い例：正規化されていない
attendance_records テーブル
| id | student_name | student_email    | class_name | teacher_name | date       |
| 1  | 田中太郎     | tanaka@test.com  | Ruby入門   | 山田先生     | 2026-01-01 |
| 2  | 田中太郎     | tanaka@test.com  | Ruby入門   | 山田先生     | 2026-01-08 |
| 3  | 佐藤花子     | sato@test.com    | Ruby入門   | 山田先生     | 2026-01-01 |

→ 田中太郎の情報、Ruby入門の情報が重複している！
→ メールアドレスを変更すると全行を更新する必要がある
```

```
✅ 良い例：正規化されている
users テーブル
| id | name     | email           |
| 1  | 田中太郎 | tanaka@test.com |
| 2  | 佐藤花子 | sato@test.com   |

school_classes テーブル
| id | name     | teacher_id |
| 1  | Ruby入門 | 3          |

teachers テーブル
| id | name     |
| 3  | 山田先生 |

attendance_records テーブル
| id | user_id | school_class_id | date       |
| 1  | 1       | 1               | 2026-01-01 |
| 2  | 1       | 1               | 2026-01-08 |
| 3  | 2       | 1               | 2026-01-01 |

→ 各情報は1箇所だけ
→ メールアドレス変更はusersテーブルの1行だけ
```

### 正規化のメリット・デメリット

| メリット | デメリット |
|:---|:---|
| データの一貫性が保たれる | テーブル結合（JOIN）が増える |
| 更新が1箇所で済む | クエリが複雑になる |
| ストレージ効率が良い | 読み取りが少し遅くなる |

<br>

---

## 6-2. 外部キー制約

### 外部キーとは？

「このカラムは別のテーブルのidを参照している」という制約です。

```ruby
# db/migrate/xxx_create_attendance_records.rb
create_table :attendance_records do |t|
  t.references :user, null: false, foreign_key: true
  t.references :school_class, null: false, foreign_key: true
  # ...
end
```

### 外部キー制約のメリット

| メリット | 説明 |
|:---|:---|
| **データ整合性** | 存在しないuser_idは登録できない |
| **カスケード削除** | ユーザー削除時に関連データも自動削除（設定による） |
| **ドキュメント** | テーブル間の関係が明確になる |

```ruby
# 外部キー制約があると...
AttendanceRecord.create!(user_id: 9999, ...)  
# → エラー！user_id=9999のユーザーは存在しない

# 外部キー制約がないと...
AttendanceRecord.create!(user_id: 9999, ...)  
# → 登録できてしまう（データ不整合）
```

<br>

---

## 6-3. JSONBの活用

### いつJSONBを使うか？

| 使う場面 | 例 |
|:---|:---|
| スキーマが不定 | 通知設定（ユーザーによって項目が違う） |
| 頻繁に構造が変わる | 位置情報（将来的に項目追加の可能性） |
| 配列データ | 履修した曜日のリスト |

### このシステムでのJSONB使用例

```ruby
# User#settings
{
  "email_notify": true,
  "line_notify": false,
  "push_notify": true,
  "notify_before_minutes": 10
}

# AttendanceRecord#location
{
  "latitude": 34.6615,
  "longitude": 135.5059,
  "accuracy": 10,
  "timestamp": "2026-01-01T09:15:00Z"
}
```

### JSONBの検索

```ruby
# PostgreSQL の JSONB は検索が高速
User.where("settings->>'email_notify' = ?", 'true')

# インデックスも作成可能
add_index :users, "(settings->>'email_notify')", using: :gin
```

<br>

---

## 6-4. インデックス最適化

### インデックスとは？

本の索引のようなもの。検索を高速化します。

```
インデックスなし：全行を順番にチェック（O(n)）
| id | user_id | date       | status  |
| 1  | 1       | 2026-01-01 | present | ← チェック
| 2  | 2       | 2026-01-01 | present | ← チェック
| 3  | 1       | 2026-01-08 | present | ← チェック
...1000行チェック...

インデックスあり：ツリー構造で高速検索（O(log n)）
user_id インデックス
     2
    / \
   1   3
  / \
 ...  ...
→ user_id=1 を3回の比較で見つけられる
```

### このシステムのインデックス

```ruby
# よく検索する条件にインデックスを追加
add_index :attendance_records, [:school_class_id, :date]  # クラス×日付で検索
add_index :attendance_records, [:user_id, :date]          # ユーザー×日付で検索
add_index :qr_scan_events, :created_at                    # 時系列で検索
```

### インデックスの注意点

| メリット | デメリット |
|:---|:---|
| 検索が速くなる | INSERT/UPDATE が少し遅くなる |
| ORDER BY が速くなる | ストレージを消費する |

<br>

---
---

# PART 7: セキュリティ設計

---

## 7-1. 認証と認可の違い

### 認証（Authentication）

「**誰か**」を確認すること。

```
認証の流れ：
1. ユーザーが email + password を入力
2. email でユーザーを検索
3. password が正しいか確認（bcryptで照合）
4. 正しければセッションにユーザーIDを保存
5. 以降はセッションIDだけで本人確認
```

### 認可（Authorization）

「**何ができるか**」を確認すること。

```
認可の流れ：
1. ユーザーが /admin にアクセス
2. セッションからユーザーIDを取得
3. ユーザーのロールを確認
4. admin ロールでなければ拒否
```

### このシステムでの実装

```ruby
# 認証：app/controllers/sessions_controller.rb
def create
  user = User.find_by(email: params[:email])
  if user&.authenticate(params[:password])  # ← 認証
    session[:user_id] = user.id
    redirect_to root_path
  else
    flash.now[:alert] = 'メールアドレスまたはパスワードが違います'
    render :new
  end
end

# 認可：app/controllers/application_controller.rb
def require_role!(*roles)
  unless roles.any? { |role| current_user.send("#{role}?") }  # ← 認可
    redirect_to root_path, alert: '権限がありません'
  end
end
```

<br>

---

## 7-2. 署名付きトークンの仕組み

### なぜQRコードに署名が必要か？

```
❌ 署名なしの場合：
QRの値 = "session_id=123&class_id=456"
→ 誰でも偽造できる！

✅ 署名ありの場合：
QRの値 = "session_id=123&class_id=456--a8f3b2c1d4e5..."
                                      ↑ 署名（秘密鍵がないと作れない）
→ 署名が一致しないと拒否
```

### MessageVerifierの仕組み

```ruby
# トークン生成
class AttendanceToken
  def self.generate(session_id:, class_id:, expires_at:)
    data = { session_id: session_id, class_id: class_id, expires_at: expires_at }
    verifier = Rails.application.message_verifier('attendance_token')
    verifier.generate(data, expires_at: expires_at)
  end
  
  def self.verify(token)
    verifier = Rails.application.message_verifier('attendance_token')
    verifier.verified(token)  # 署名が正しければデータを返す、不正ならnil
  rescue ActiveSupport::MessageVerifier::InvalidSignature
    nil
  end
end

# 使い方
token = AttendanceToken.generate(session_id: 1, class_id: 2, expires_at: 5.minutes.from_now)
# => "eyJzZXNzaW9uX2lkIjoxLCJjbGFzc19pZCI6Mn0=--a8f3b2c1d4e5f6..."

data = AttendanceToken.verify(token)
# => { session_id: 1, class_id: 2, expires_at: ... }

# 改ざんされたトークン
AttendanceToken.verify("改ざんされた文字列")
# => nil
```

<br>

---

## 7-3. 位置情報認証（ジオフェンス）

### ジオフェンスとは？

仮想的な「囲い」を作り、その中にいるかどうかを判定する技術。

```
                  半径50m
            ╭───────────────╮
            │               │
            │   ⭐ 学校     │
            │               │
            │    📱 OK      │
            ╰───────────────╯
                        📱 NG（範囲外）
```

### 距離計算（ハーバーサイン公式）

地球は球体なので、単純な引き算では距離が計算できません。

```ruby
# app/services/geo_calculator.rb
class GeoCalculator
  EARTH_RADIUS_KM = 6371.0  # 地球の半径
  
  def self.distance_km(lat1, lng1, lat2, lng2)
    # 緯度経度をラジアンに変換
    lat1_rad = lat1 * Math::PI / 180
    lat2_rad = lat2 * Math::PI / 180
    delta_lat = (lat2 - lat1) * Math::PI / 180
    delta_lng = (lng2 - lng1) * Math::PI / 180
    
    # ハーバーサイン公式
    a = Math.sin(delta_lat / 2) ** 2 +
        Math.cos(lat1_rad) * Math.cos(lat2_rad) *
        Math.sin(delta_lng / 2) ** 2
    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
    
    EARTH_RADIUS_KM * c
  end
  
  def self.within_radius?(lat, lng, center_lat, center_lng, radius_m)
    distance_m = distance_km(lat, lng, center_lat, center_lng) * 1000
    distance_m <= radius_m
  end
end

# 使い方
GeoCalculator.within_radius?(
  34.6615, 135.5059,  # ユーザーの位置
  34.6620, 135.5055,  # 学校の位置
  50                   # 半径50m
)
# => true（50m以内）
```

<br>

---

## 7-4. 不正検知の仕組み

### 検知パターン

| パターン | 条件 | 意味 |
|:---|:---|:---|
| **失敗多発** | 2分内に4回以上失敗 | 不正なトークンを試している |
| **IP集中** | 1分内に同一IPから8回以上 | 1人が複数人分をスキャン |
| **トークン共有** | 2分内に同一トークンを2人以上が使用 | QRを写真で共有 |

### 検知ロジック

```ruby
# app/services/fraud_detector.rb
class FraudDetector
  def self.check(user:, ip:, token_digest:)
    alerts = []
    
    # 失敗多発チェック
    recent_failures = QrScanEvent
      .where(user: user, status: 'failure')
      .where('created_at > ?', 2.minutes.ago)
      .count
    alerts << :too_many_failures if recent_failures >= 4
    
    # IP集中チェック
    recent_from_ip = QrScanEvent
      .where(ip: ip)
      .where('created_at > ?', 1.minute.ago)
      .count
    alerts << :ip_burst if recent_from_ip >= 8
    
    # トークン共有チェック
    recent_users = QrScanEvent
      .where(token_digest: token_digest)
      .where('created_at > ?', 2.minutes.ago)
      .distinct
      .count(:user_id)
    alerts << :token_sharing if recent_users >= 2
    
    alerts
  end
end
```

<br>

---
---

# PART 8: テスト設計

---

## 8-1. テストの種類と目的

### テストピラミッド

```
          ╱╲
         ╱  ╲
        ╱ E2E ╲        少ない（遅い、コスト高）
       ╱──────╲
      ╱ 結合テスト ╲     中程度
     ╱────────────╲
    ╱   単体テスト    ╲   多い（速い、コスト低）
   ╱──────────────────╲
```

| 種類 | 範囲 | 速度 | このシステムでの例 |
|:---|:---|:---|:---|
| **単体テスト** | 1メソッド | 速い | `AttendancePolicy#late?` |
| **結合テスト** | 複数クラス | 中程度 | ログイン→ダッシュボード |
| **E2Eテスト** | ブラウザ操作 | 遅い | QRスキャンの全フロー |

<br>

---

## 8-2. 単体テストの書き方

### RSpecの基本構文

```ruby
# spec/models/attendance_policy_spec.rb
RSpec.describe AttendancePolicy do
  describe '#determine_status' do
    let(:policy) { AttendancePolicy.new(late_after_minutes: 20) }
    let(:class_start) { Time.zone.parse('2026-01-01 09:10:00') }
    
    context '授業開始10分後にスキャンした場合' do
      let(:scanned_at) { class_start + 10.minutes }
      
      it 'present を返す' do
        result = policy.determine_status(scanned_at: scanned_at, class_start: class_start)
        expect(result).to eq :present
      end
    end
    
    context '授業開始25分後にスキャンした場合' do
      let(:scanned_at) { class_start + 25.minutes }
      
      it 'late を返す' do
        result = policy.determine_status(scanned_at: scanned_at, class_start: class_start)
        expect(result).to eq :late
      end
    end
  end
end
```

### テストの構造（AAA パターン）

```ruby
it 'テストの説明' do
  # Arrange（準備）
  user = create(:user)
  token = AttendanceToken.generate(...)
  
  # Act（実行）
  result = QrScanProcessor.new(token: token, user: user).process
  
  # Assert（検証）
  expect(result).to be_success
end
```

<br>

---

## 8-3. 境界値テスト

### なぜ境界値が重要か？

バグは「境界」で起きやすいです。

```
遅刻判定: 20分後

よくあるバグ：
- 20分ちょうどは出席？遅刻？
- 20分01秒は？19分59秒は？
- 端数の処理は？
```

### 境界値テストの例

```ruby
RSpec.describe AttendancePolicy do
  let(:policy) { AttendancePolicy.new(late_after_minutes: 20) }
  let(:class_start) { Time.zone.parse('2026-01-01 09:10:00') }
  
  describe '遅刻判定の境界値' do
    # 境界の内側
    it '19分59秒後は出席' do
      scanned_at = class_start + 19.minutes + 59.seconds
      expect(policy.determine_status(scanned_at: scanned_at, class_start: class_start))
        .to eq :present
    end
    
    # 境界ちょうど
    it '20分00秒後は出席' do  # ちょうどは出席扱いとする設計
      scanned_at = class_start + 20.minutes
      expect(policy.determine_status(scanned_at: scanned_at, class_start: class_start))
        .to eq :present
    end
    
    # 境界の外側
    it '20分01秒後は遅刻' do
      scanned_at = class_start + 20.minutes + 1.second
      expect(policy.determine_status(scanned_at: scanned_at, class_start: class_start))
        .to eq :late
    end
  end
end
```

<br>

---

## 8-4. 結合テストの書き方

### システムスペックの例

```ruby
# spec/system/login_spec.rb
RSpec.describe 'ログイン', type: :system do
  let!(:user) { create(:user, email: 'test@example.com', password: 'password') }
  
  describe 'ログイン成功' do
    it 'ダッシュボードに遷移する' do
      visit login_path
      fill_in 'メールアドレス', with: 'test@example.com'
      fill_in 'パスワード', with: 'password'
      click_button 'ログイン'
      
      expect(page).to have_current_path(root_path)
      expect(page).to have_content('ログインしました')
    end
  end
  
  describe 'ログイン失敗' do
    it 'エラーメッセージが表示される' do
      visit login_path
      fill_in 'メールアドレス', with: 'test@example.com'
      fill_in 'パスワード', with: 'wrong_password'
      click_button 'ログイン'
      
      expect(page).to have_current_path(login_path)
      expect(page).to have_content('メールアドレスまたはパスワードが違います')
    end
  end
end
```

<br>

---
---

# PART 9: 開発・運用

---

## 9-1. 環境変数の管理

### なぜ環境変数を使うのか？

```ruby
# ❌ 危険：コードに直接書く
DATABASE_URL = "postgres://user:password@localhost/mydb"
# → GitHubに公開されると全世界にパスワードがバレる

# ✅ 安全：環境変数から読み込む
DATABASE_URL = ENV["DATABASE_URL"]
# → コードには変数名だけ、実際の値はサーバーの設定
```

### 環境ごとの値の違い

| 環境変数 | 開発環境 | 本番環境 |
|:---|:---|:---|
| DATABASE_URL | `postgres://localhost/dev_db` | `postgres://xxx.render.com/prod_db` |
| RAILS_ENV | `development` | `production` |
| SECRET_KEY_BASE | (自動生成) | (ランダムな長い文字列) |

### Railsでの環境変数の使い方

```ruby
# 直接参照
ENV["DATABASE_URL"]

# デフォルト値付き
ENV.fetch("PORT", 3000)  # PORTがなければ3000

# credentials.yml.enc を使う（Rails推奨）
Rails.application.credentials.dig(:sendgrid, :api_key)
```

<br>

---

## 9-2. デプロイの流れ

### Render.comへのデプロイ

```
ローカル（自分のPC）
     │
     │ git push
     ▼
GitHub（コード保管庫）
     │
     │ Webhook（自動通知）
     ▼
Render.com
     │
     │ 1. コードを取得
     │ 2. bundle install（依存関係インストール）
     │ 3. assets:precompile（CSS/JS ビルド）
     │ 4. db:migrate（DBスキーマ更新）
     │ 5. アプリ起動
     ▼
本番環境（ユーザーがアクセス）
```

### bin/render-build.sh の内容

```bash
#!/usr/bin/env bash
set -o errexit  # エラーで停止

# 依存関係インストール
bundle install

# アセットビルド
bundle exec rails assets:precompile
bundle exec rails assets:clean

# DBマイグレーション
bundle exec rails db:migrate
```

<br>

---

## 9-3. ログの重要性

### なぜログが必要か？

```
本番で問題発生！
「学生Aが出席できなかったらしい」
  ↓
ログがなければ...
「いつ？どのクラス？何のエラー？」→ 調査不能

ログがあれば...
[2026-01-01 09:15:32] user_id=123 class_id=456 error=outside_geofence location={lat:34.0,lng:135.0}
→ 「位置情報が範囲外だった」と特定できる
```

### このシステムのログ設計

| テーブル | 記録内容 |
|:---|:---|
| `qr_scan_events` | スキャンの成功/失敗、IP、ブラウザ |
| `attendance_changes` | 出席変更の履歴、変更者、理由 |

```ruby
# app/services/qr_scan_event_logger.rb
class QrScanEventLogger
  def self.log(user:, qr_session:, status:, ip:, user_agent:, error_code: nil)
    QrScanEvent.create!(
      user: user,
      qr_session: qr_session,
      status: status,
      ip: ip,
      user_agent: user_agent,
      error_code: error_code,
      created_at: Time.current
    )
  end
end
```

<br>

---
---

# PART 10: 就活・ポートフォリオ

---

## 10-1. 面接で聞かれそうな質問と回答例

### Q1. このシステムの特徴は？

> 「QRコードと位置情報認証を組み合わせた出席管理システムです。  
> 署名付きトークンで改ざんを防止し、ジオフェンスで代返を防いでいます。  
> また、承認ワークフローと監査ログで実運用にも耐える設計になっています。」

### Q2. なぜこの技術スタックを選んだ？

> 「Rails 8とHotwireを選んだ理由は3つあります。  
> 1つ目は、Turbo Streamによるリアルタイム更新が出席管理に適していたこと。  
> 2つ目は、SPAフレームワークより学習コストが低く、少人数で開発できること。  
> 3つ目は、Railsの規約に従うことで設計判断に迷う時間を減らせることです。」

### Q3. 苦労した点は？

> 「位置情報の精度問題です。GPSは環境によって±10m〜100m程度の誤差があります。  
> 対策として、精度が150mを超える場合は拒否し、50m〜150mの場合は警告を表示する設計にしました。  
> また、校内半径を50mと余裕を持たせることで、多少の誤差があっても正しく判定できるようにしています。」

### Q4. セキュリティで工夫した点は？

> 「主に4つの対策をしています。  
> 1. MessageVerifierによる署名付きトークンで、QRコードの偽造を防止  
> 2. ジオフェンスで、校外からの代返を物理的に防止  
> 3. レート制限で、短時間の連続アクセスを制限  
> 4. 不正検知で、失敗多発やIP集中を検知して教員に通知」

### Q5. 改善したい点は？

> 「現在はメール・LINE・Push通知を実装済みですが、通知の種類や条件をさらに細かく設定できるようにしたいです。
> また、単一校舎を想定した設計なので、複数キャンパス対応も検討しています。
> 技術的には、Bluetooth Beaconによる屋内測位で、より正確な位置判定ができると考えています。」

<br>

---

## 10-2. ポートフォリオに書くべきポイント

### 必須項目

| 項目 | 書くこと | 例 |
|:---|:---|:---|
| **概要** | 1〜2文でシステムの目的 | QRと位置情報で出席を管理するシステム |
| **技術スタック** | 言語/FW/DB/その他 | Ruby 3.3 / Rails 8 / PostgreSQL / Tailwind |
| **担当範囲** | 自分が実装した機能 | 全機能（個人開発） |
| **工夫した点** | 技術的なチャレンジ | 署名トークン、ジオフェンス、リアルタイム更新 |
| **学んだこと** | 開発を通じて得た知識 | セキュリティ設計、Service Object パターン |
| **デモURL** | 動いているサイトのURL | https://xxx.onrender.com |
| **GitHub** | ソースコードのURL | https://github.com/xxx/attendance |

### 差がつくポイント

| ポイント | 説明 |
|:---|:---|
| **「なぜ」を書く** | 技術選定の理由、設計判断の理由 |
| **数字を入れる** | 「3ロール」「50m以内」「5分で失効」 |
| **図を入れる** | システム構成図、ER図、画面遷移図 |
| **困難と解決** | 問題→原因→対策の流れ |

<br>

---

## 10-3. 参考リンク

| トピック | URL |
|:---|:---|
| Ruby on Rails ガイド（日本語） | https://railsguides.jp/ |
| Hotwire 公式 | https://hotwired.dev/ |
| Tailwind CSS 公式 | https://tailwindcss.com/ |
| Mermaid 公式 | https://mermaid.js.org/ |
| PostgreSQL 公式（日本語） | https://www.postgresql.jp/ |
| RSpec 公式 | https://rspec.info/ |
| bcrypt 解説 | https://auth0.com/blog/hashing-in-action-understanding-bcrypt/ |
| ジオフェンス解説 | https://developer.mozilla.org/ja/docs/Web/API/Geolocation_API |

<br>

---

## 10-4. 学習ロードマップ

### このシステムを理解するための学習順序

```
1. Ruby 基礎（2週間）
   - 変数、条件分岐、ループ
   - クラス、メソッド、ブロック
   
2. Rails 基礎（3週間）
   - MVC パターン
   - ルーティング、Controller、View
   - Model、ActiveRecord
   
3. データベース（2週間）
   - SQL 基礎
   - 正規化、外部キー
   - インデックス
   
4. セキュリティ（1週間）
   - 認証と認可
   - ハッシュ化
   - CSRF、XSS 対策
   
5. フロントエンド（2週間）
   - HTML/CSS
   - JavaScript 基礎
   - Stimulus
   
6. 実践（4週間〜）
   - このシステムのコードを読む
   - 小さな機能を追加してみる
   - テストを書いてみる
```
